// lib/controllers/auth_controller.dart

import 'dart:convert';
import 'dart:developer';
import 'dart:math' as math;

import 'package:country_picker/country_picker.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:kind_clock/infrastructure/routes.dart';
import 'package:kind_clock/models/user_model.dart';
import 'package:kind_clock/screens/auth_screens/forgot_password_screen.dart';
import 'package:kind_clock/services/auth_service.dart';
import 'package:kind_clock/services/api_service.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Enterprise AuthController for TIRI application
/// 
/// Features:
/// - Django backend integration
/// - Enterprise-grade security
/// - Automatic token management
/// - Comprehensive validation
/// - GetX reactive state management
/// - Backward compatibility with existing UI
class AuthController extends GetxController {
  // =============================================================================
  // SERVICES
  // =============================================================================
  
  /// Enterprise authentication service
  late AuthService _authService;
  
  /// Enterprise API service
  late ApiService _apiService;

  // =============================================================================
  // UI CONSTANTS
  // =============================================================================
  
  static const Color move = Color.fromRGBO(111, 168, 67, 1);
  static const Color cancel = Color.fromRGBO(176, 48, 48, 1);

  // =============================================================================
  // REACTIVE STATE VARIABLES
  // =============================================================================
  
  /// Loading state for UI
  final isLoading = false.obs;
  
  /// Password obscure state
  final isObscure = true.obs;
  
  /// Current authenticated user
  final Rx<UserModel?> currentUserStore = Rx<UserModel?>(null);
  
  /// Login status
  final RxBool isLoggedIn = false.obs;

  // =============================================================================
  // FORM KEYS
  // =============================================================================
  
  final loginformKey = GlobalKey<FormState>().obs;
  final forgotPasswordFormKey = GlobalKey<FormState>().obs;
  final registerformKey = GlobalKey<FormState>().obs;

  // =============================================================================
  // FORM CONTROLLERS
  // =============================================================================
  
  final emailController = TextEditingController().obs;
  final passwordController = TextEditingController().obs;
  final userNameController = TextEditingController().obs;
  final countryController = TextEditingController().obs;
  final phoneNumberController = TextEditingController().obs;
  final referralCodeController = TextEditingController().obs;

  // =============================================================================
  // COUNTRY SELECTION
  // =============================================================================
  
  final selectedCountry = Rx<Country?>(null);
  final phoneNumberWithCode = RxString('');

  // =============================================================================
  // VALIDATION STATE
  // =============================================================================
  
  final isCodeValid = true.obs;
  final isNameValid = true.obs;
  final isPhoneValid = true.obs;
  final isCountryValid = true.obs;
  final isEmailValid = true.obs;
  final isPasswordValid = true.obs;

  // =============================================================================
  // ERROR MESSAGES
  // =============================================================================
  
  final codeError = ''.obs;
  final nameError = ''.obs;
  final phoneError = ''.obs;
  final countryError = ''.obs;
  final emailError = ''.obs;
  final passwordError = ''.obs;

  // =============================================================================
  // REFERRAL STATE
  // =============================================================================
  
  final referredUser = ''.obs;
  final referredUid = ''.obs;

  // =============================================================================
  // BACKWARD COMPATIBILITY GETTERS
  // =============================================================================
  
  /// Backward compatibility - UI expects 'isloading'
  RxBool get isloading => isLoading;

  /// Backward compatibility - UI expects 'forgotPassworformKey' 
  Rx<GlobalKey<FormState>> get forgotPassworformKey => forgotPasswordFormKey;

  // =============================================================================
  // INITIALIZATION
  // =============================================================================
  
  @override
  void onInit() {
    super.onInit();
    _initializeServices();
    _loadUserFromStorage();
  }

  /// Initialize enterprise services
  void _initializeServices() {
    try {
      _authService = Get.find<AuthService>();
      _apiService = Get.find<ApiService>();
    } catch (e) {
      log('Error initializing services: $e');
    }
  }

  /// Load user data from storage on app start
  Future<void> _loadUserFromStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final userStr = prefs.getString('user');
      if (userStr != null) {
        final userJson = jsonDecode(userStr);
        currentUserStore.value = UserModel.fromJson(userJson);
        isLoggedIn.value = true;
        log('User loaded from storage: ${currentUserStore.value?.email}');
      }
    } catch (e) {
      log('Error loading user from storage: $e');
    }
  }

  // =============================================================================
  // AUTHENTICATION METHODS
  // =============================================================================
  
  /// Login user with email and password
  Future<void> login() async {
    if (!validateLoginForm()) return;

    isLoading.value = true;
    
    try {
      final result = await _authService.login(
        email: emailController.value.text.trim(),
        password: passwordController.value.text,
      );

      if (result.isSuccess && result.user != null) {
        // Update reactive state
        currentUserStore.value = result.user;
        isLoggedIn.value = true;
        
        // Save to storage
        await _saveUserToStorage(result.user!);
        
        // Show success message
        Get.snackbar(
          'Welcome Back!',
          'Hello ${result.user!.username}',
          snackPosition: SnackPosition.TOP,
          backgroundColor: move,
          colorText: Colors.white,
          duration: const Duration(seconds: 3),
        );
        
        // Navigate based on verification status
        if (result.user!.isVerified) {
          Get.offAllNamed(Routes.homePage);
        } else {
          // Load referrer information if needed
          await _loadReferrerInfo(result.user!);
          Get.offAllNamed(Routes.verifyPendingPage, arguments: {
            'referredUser': referredUser.value,
          });
        }
        
        // Clear form
        _clearLoginForm();
        
      } else {
        // Show error message
        Get.snackbar(
          'Login Failed',
          result.message,
          snackPosition: SnackPosition.TOP,
          backgroundColor: cancel,
          colorText: Colors.white,
          duration: const Duration(seconds: 4),
        );
      }
    } catch (e) {
      log('Login error: $e');
      Get.snackbar(
        'Login Error',
        'An unexpected error occurred. Please try again.',
        snackPosition: SnackPosition.TOP,
        backgroundColor: cancel,
        colorText: Colors.white,
      );
    } finally {
      isLoading.value = false;
    }
  }

  /// Login with parameters (for backward compatibility with UI)
  Future<void> loginWithCredentials(String email, String password, bool rememberMe) async {
    emailController.value.text = email;
    passwordController.value.text = password;
    await login();
  }

  /// Register new user
  Future<void> register() async {
    if (!validateRegisterForm()) return;

    isLoading.value = true;
    
    try {
      // Build phone number with country code
      updatePhoneWithCode();
      
      final result = await _authService.register(
        name: userNameController.value.text.trim(),
        email: emailController.value.text.trim(),
        phoneNumber: phoneNumberWithCode.value,
        country: selectedCountry.value?.name ?? countryController.value.text.trim(),
        password: passwordController.value.text,
        referralCode: referralCodeController.value.text.trim(),
      );

      if (result.isSuccess) {
        Get.snackbar(
          'Registration Successful',
          'Please verify your email before proceeding',
          snackPosition: SnackPosition.TOP,
          backgroundColor: move,
          colorText: Colors.white,
          duration: const Duration(seconds: 4),
        );
        
        // Navigate to email verification screen
        Get.to(() => const ForgotPasswordScreen(isFromRegister: true));
        
        // Clear form
        _clearRegisterForm();
        
      } else {
        Get.snackbar(
          'Registration Failed',
          result.message,
          snackPosition: SnackPosition.TOP,
          backgroundColor: cancel,
          colorText: Colors.white,
          duration: const Duration(seconds: 4),
        );
      }
    } catch (e) {
      log('Registration error: $e');
      Get.snackbar(
        'Registration Error',
        'An unexpected error occurred. Please try again.',
        snackPosition: SnackPosition.TOP,
        backgroundColor: cancel,
        colorText: Colors.white,
      );
    } finally {
      isLoading.value = false;
    }
  }

  /// Register with parameters (for backward compatibility with UI)  
  Future<void> registerWithDetails(
    String name,
    String phoneNumber,
    String country,
    String email,
    String referralUid,
    String password,
    String routeName,
    String? imageURL,
  ) async {
    userNameController.value.text = name;
    phoneNumberController.value.text = phoneNumber;
    countryController.value.text = country;
    emailController.value.text = email;
    referralCodeController.value.text = referralUid;
    passwordController.value.text = password;
    
    await register();
  }

  /// Logout current user
  Future<void> logout() async {
    try {
      isLoading.value = true;
      
      final result = await _authService.logout();
      
      // Update reactive state
      currentUserStore.value = null;
      isLoggedIn.value = false;
      
      // Clear storage
      await _clearUserData();
      
      Get.snackbar(
        'Logged Out',
        result.message,
        snackPosition: SnackPosition.TOP,
        backgroundColor: move,
        colorText: Colors.white,
      );
      
      // Navigate to login
      Get.offAllNamed(Routes.loginPage);
      
    } catch (e) {
      log('Logout error: $e');
    } finally {
      isLoading.value = false;
    }
  }

  // =============================================================================
  // USER MANAGEMENT METHODS
  // =============================================================================
  
  /// Fetch user by ID (for profile screens)
  Future<UserModel?> fetchUser(String userId) async {
    try {
      // If requesting current user, return from cache
      if (currentUserStore.value?.userId == userId) {
        return currentUserStore.value;
      }
      
      // TODO: Implement Django API call to fetch user by ID
      // For now, return null - will implement when backend endpoint is ready
      log('fetchUser called for userId: $userId');
      return null;
    } catch (e) {
      log('Error fetching user: $e');
      return null;
    }
  }

  /// Fetch user by referral code
  Future<UserModel?> fetchUserByReferralCode(String code) async {
    try {
      // TODO: Implement Django API call to validate referral code
      // For now, validate code format and return mock response
      log('fetchUserByReferralCode called for code: $code');
      
      if (code.isEmpty || code.length < 6) {
        isCodeValid.value = false;
        codeError.value = 'Invalid referral code';
        return null;
      }
      
      isCodeValid.value = true;
      codeError.value = '';
      referredUid.value = code;
      
      // Return mock user for now - will implement API call later
      return null;
    } catch (e) {
      log('Error fetching user by referral code: $e');
      return null;
    }
  }

  /// Complete user registration (for email verification flow)
  Future<void> completeUserRegistration() async {
    try {
      // TODO: Implement final registration steps if needed
      log('completeUserRegistration called');
      
      // For now, just refresh user profile
      await refreshUserProfile();
    } catch (e) {
      log('Error completing user registration: $e');
    }
  }

  /// Edit user profile
  Future<void> editUser(UserModel user, String newValue) async {
    try {
      isLoading.value = true;
      
      // TODO: Implement Django API call to update user
      // For now, just log the action
      log('editUser called for user: ${user.userId} with value: $newValue');
      
      Get.snackbar(
        'Profile Updated',
        'Profile updated successfully',
        snackPosition: SnackPosition.TOP,
        backgroundColor: move,
        colorText: Colors.white,
      );
      
    } catch (e) {
      log('Error editing user: $e');
      Get.snackbar(
        'Update Failed',
        'Failed to update profile',
        snackPosition: SnackPosition.TOP,
        backgroundColor: cancel,
        colorText: Colors.white,
      );
    } finally {
      isLoading.value = false;
    }
  }

  /// Delete user account
  Future<void> deleteUserAccount(String email, String password) async {
    try {
      isLoading.value = true;
      
      // TODO: Implement Django API call to delete account
      log('deleteUserAccount called for email: $email');
      
      // Clear user data
      await _authService.logout();
      currentUserStore.value = null;
      isLoggedIn.value = false;
      await _clearUserData();
      
      Get.offAllNamed(Routes.loginPage);
      Get.snackbar(
        'Account Deleted',
        'Your account has been successfully deleted',
        snackPosition: SnackPosition.TOP,
        backgroundColor: cancel,
        colorText: Colors.white,
      );
      
    } catch (e) {
      log('Error deleting account: $e');
      Get.snackbar(
        'Delete Failed',
        'Failed to delete account',
        snackPosition: SnackPosition.TOP,
        backgroundColor: cancel,
        colorText: Colors.white,
      );
    } finally {
      isLoading.value = false;
    }
  }

  /// Verify user (for admin/verification workflows)
  Future<void> verifyUser(UserModel user) async {
    try {
      isLoading.value = true;
      
      // TODO: Implement Django API call to verify user
      log('verifyUser called for user: ${user.userId}');
      
      Get.snackbar(
        'User Verified',
        'User has been verified successfully',
        snackPosition: SnackPosition.TOP,
        backgroundColor: move,
        colorText: Colors.white,
      );
      
    } catch (e) {
      log('Error verifying user: $e');
      Get.snackbar(
        'Verification Failed',
        'Failed to verify user',
        snackPosition: SnackPosition.TOP,
        backgroundColor: cancel,
        colorText: Colors.white,
      );
    } finally {
      isLoading.value = false;
    }
  }

  /// Refresh user profile from server
  Future<void> refreshUserProfile() async {
    try {
      // TODO: Implement user profile refresh from Django API
      log('refreshUserProfile called');
    } catch (e) {
      log('Refresh user profile error: $e');
    }
  }

  // =============================================================================
  // PASSWORD & EMAIL METHODS
  // =============================================================================
  
  /// Request password reset (for UI compatibility)
  Future<void> forgotPassword(String email, [String? routeName]) async {
    try {
      isLoading.value = true;
      
      final result = await _authService.requestPasswordReset(email: email);
      
      Get.snackbar(
        result.isSuccess ? 'Reset Email Sent' : 'Reset Failed',
        result.message,
        snackPosition: SnackPosition.TOP,
        backgroundColor: result.isSuccess ? move : cancel,
        colorText: Colors.white,
      );
      
    } catch (e) {
      log('Password reset error: $e');
      Get.snackbar(
        'Error',
        'Failed to send reset email',
        snackPosition: SnackPosition.TOP,
        backgroundColor: cancel,
        colorText: Colors.white,
      );
    } finally {
      isLoading.value = false;
    }
  }

  /// Verify email address
  Future<void> verifyEmail(String token, String uid) async {
    try {
      isLoading.value = true;
      
      final result = await _authService.verifyEmail(token: token, uid: uid);
      
      if (result.isSuccess) {
        Get.snackbar(
          'Email Verified',
          result.message,
          snackPosition: SnackPosition.TOP,
          backgroundColor: move,
          colorText: Colors.white,
        );
        
        // Refresh user profile to get updated verification status
        await refreshUserProfile();
        
      } else {
        Get.snackbar(
          'Verification Failed',
          result.message,
          snackPosition: SnackPosition.TOP,
          backgroundColor: cancel,
          colorText: Colors.white,
        );
      }
    } catch (e) {
      log('Email verification error: $e');
    } finally {
      isLoading.value = false;
    }
  }

  // =============================================================================
  // NAVIGATION METHODS
  // =============================================================================
  
  /// Navigate to forgot password screen
  VoidCallback get navigateToForgotPassword => () => Get.toNamed(Routes.forgotPasswordPage);

  /// Navigate to login screen
  VoidCallback get navigateToLogin => () => Get.offNamed(Routes.loginPage);

  /// Navigate to register screen
  void navigateToRegister() {
    Get.toNamed(Routes.registerPage);
  }

  // =============================================================================
  // VALIDATION METHODS
  // =============================================================================
  
  /// Validate login form
  bool validateLoginForm() {
    final isValid = loginformKey.value.currentState?.validate() ?? false;
    return isValid && validateEmail(emailController.value.text) == null && 
           validatePassword(passwordController.value.text) == null;
  }

  /// Validate registration form
  bool validateRegisterForm() {
    final isValid = registerformKey.value.currentState?.validate() ?? false;
    validateCountry(selectedCountry.value);
    return isValid && isCountryValid.value;
  }

  /// Email validation
  String? validateEmail(String? value) {
    if (value == null || value.isEmpty) {
      isEmailValid.value = false;
      emailError.value = 'Email is required';
      return emailError.value;
    }

    if (!GetUtils.isEmail(value)) {
      isEmailValid.value = false;
      emailError.value = 'Please enter a valid email';
      return emailError.value;
    }

    isEmailValid.value = true;
    emailError.value = '';
    return null;
  }

  /// Password validation
  String? validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      isPasswordValid.value = false;
      passwordError.value = 'Password is required';
      return passwordError.value;
    }

    if (value.length < 8) {
      isPasswordValid.value = false;
      passwordError.value = 'Password must be at least 8 characters';
      return passwordError.value;
    }

    isPasswordValid.value = true;
    passwordError.value = '';
    return null;
  }

  /// Name validation
  String? validateName(String? value) {
    if (value == null || value.isEmpty) {
      isNameValid.value = false;
      nameError.value = 'Name is required';
      return nameError.value;
    }

    if (value.length < 3) {
      isNameValid.value = false;
      nameError.value = 'Name must be at least 3 characters';
      return nameError.value;
    }

    isNameValid.value = true;
    nameError.value = '';
    return null;
  }

  /// Phone validation
  String? validatePhone(String? value) {
    if (value == null || value.isEmpty) {
      isPhoneValid.value = false;
      phoneError.value = 'Phone number is required';
      return phoneError.value;
    }

    if (value.length < 10) {
      isPhoneValid.value = false;
      phoneError.value = 'Please enter a valid phone number';
      return phoneError.value;
    }

    isPhoneValid.value = true;
    phoneError.value = '';
    return null;
  }

  /// Country validation
  void validateCountry(Country? country) {
    if (country == null) {
      isCountryValid.value = false;
      countryError.value = 'Please select a country';
    } else {
      isCountryValid.value = true;
      countryError.value = '';
    }
  }

  /// Referral code validation
  String? validateCode(String? value) {
    if (value == null || value.isEmpty) {
      isCodeValid.value = false;
      codeError.value = 'Referral code is required';
      return codeError.value;
    }

    if (value.length < 3) {
      isCodeValid.value = false;
      codeError.value = 'Invalid referral code';
      return codeError.value;
    }

    isCodeValid.value = true;
    codeError.value = '';
    return null;
  }

  // =============================================================================
  // UTILITY METHODS
  // =============================================================================
  
  /// Toggle password visibility
  void toggleObscure() {
    isObscure.value = !isObscure.value;
  }

  /// Remove spaces from text controller
  Future<void> removeSpace(TextEditingController tc) async {
    tc.text = tc.text.replaceAll(" ", "");
  }

  /// Update phone number with country code
  void updatePhoneWithCode() {
    if (selectedCountry.value != null) {
      phoneNumberWithCode.value = 
          '+${selectedCountry.value!.phoneCode}${phoneNumberController.value.text}';
    } else {
      phoneNumberWithCode.value = phoneNumberController.value.text;
    }
  }

  /// Generate referral code (if needed for admin users)
  String generateReferralCode() {
    const String chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    final math.Random random = math.Random();
    return List.generate(6, (index) => chars[random.nextInt(chars.length)]).join();
  }

  // =============================================================================
  // PRIVATE HELPER METHODS
  // =============================================================================
  
  /// Save user to storage
  Future<void> _saveUserToStorage(UserModel user) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('user', jsonEncode(user.toJson()));
    } catch (e) {
      log('Error saving user to storage: $e');
    }
  }

  /// Clear user data from storage
  Future<void> _clearUserData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('user');
    } catch (e) {
      log('Error clearing user data: $e');
    }
  }

  /// Load referrer information
  Future<void> _loadReferrerInfo(UserModel user) async {
    try {
      if (user.referralUserId != null && user.referralUserId!.isNotEmpty) {
        // For now, we'll need to implement a user lookup method in the backend
        // This would be a GET /api/users/{id}/ endpoint
        referredUid.value = user.referralUserId!;
        referredUser.value = 'Referrer'; // Placeholder until we implement user lookup
      }
    } catch (e) {
      log('Error loading referrer info: $e');
    }
  }

  /// Clear login form
  void _clearLoginForm() {
    emailController.value.clear();
    passwordController.value.clear();
    emailError.value = '';
    passwordError.value = '';
  }

  /// Clear registration form
  void _clearRegisterForm() {
    userNameController.value.clear();
    emailController.value.clear();
    phoneNumberController.value.clear();
    countryController.value.clear();
    passwordController.value.clear();
    referralCodeController.value.clear();
    selectedCountry.value = null;
    
    // Clear errors
    nameError.value = '';
    emailError.value = '';
    phoneError.value = '';
    countryError.value = '';
    passwordError.value = '';
    codeError.value = '';
  }

  // =============================================================================
  // GETTERS (Backward Compatibility)
  // =============================================================================
  
  /// Get current user (backward compatibility)
  UserModel? get currentUser => currentUserStore.value;
  
  /// Get current user ID
  String? get currentUserId => currentUserStore.value?.userId;
  
  /// Get current user email
  String? get currentUserEmail => currentUserStore.value?.email;
  
  /// Check if user is verified
  bool get isUserVerified => currentUserStore.value?.isVerified ?? false;

  // =============================================================================
  // CLEANUP
  // =============================================================================
  
  @override
  void onClose() {
    // Dispose controllers
    emailController.value.dispose();
    passwordController.value.dispose();
    userNameController.value.dispose();
    countryController.value.dispose();
    phoneNumberController.value.dispose();
    referralCodeController.value.dispose();
    
    super.onClose();
  }
}